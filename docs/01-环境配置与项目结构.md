# 01-环境配置与项目结构

## 开发环境要求

- **Unity版本**: 2022.3.x（与游戏版本匹配）
- **.NET框架**: .NET Standard 2.1
- **IDE**: Visual Studio 2022 / Rider

---

## C# 项目配置

### 项目文件 (.csproj)

```xml
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>netstandard2.1</TargetFramework>
        <LangVersion>latest</LangVersion>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    </PropertyGroup>

    <!-- DLL 引用路径变量 -->
    <PropertyGroup>
        <DuckovPath>C:\Program Files (x86)\Steam\steamapps\common\Escape from Duckov</DuckovPath>
        <UnityPath>C:\Program Files\Unity\Hub\Editor\2022.3.x\Editor\Data\Managed</UnityPath>
    </PropertyGroup>

    <!-- 必需的 DLL 引用 -->
    <ItemGroup>
        <!-- 游戏核心 -->
        <Reference Include="TeamSoda.Duckov.Core">
            <HintPath>$(DuckovPath)\Duckov_Data\Managed\TeamSoda.Duckov.Core.dll</HintPath>
            <Private>false</Private>
        </Reference>
        <Reference Include="Assembly-CSharp">
            <HintPath>$(DuckovPath)\Duckov_Data\Managed\Assembly-CSharp.dll</HintPath>
            <Private>false</Private>
        </Reference>

        <!-- Unity 核心 -->
        <Reference Include="UnityEngine">
            <HintPath>$(UnityPath)\UnityEngine.dll</HintPath>
            <Private>false</Private>
        </Reference>
        <Reference Include="UnityEngine.CoreModule">
            <HintPath>$(DuckovPath)\Duckov_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
            <Private>false</Private>
        </Reference>
        <Reference Include="UnityEngine.PhysicsModule">
            <HintPath>$(DuckovPath)\Duckov_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
            <Private>false</Private>
        </Reference>
        <Reference Include="UnityEngine.UI">
            <HintPath>$(DuckovPath)\Duckov_Data\Managed\UnityEngine.UI.dll</HintPath>
            <Private>false</Private>
        </Reference>
    </ItemGroup>
</Project>
```

### 常用 DLL 说明

| DLL 文件 | 包含内容 |
|----------|----------|
| TeamSoda.Duckov.Core.dll | Item, Inventory, Effect, UsageBehavior, DamageInfo 等核心类 |
| Assembly-CSharp.dll | CharacterMainControl, LevelManager, StockShopDatabase 等游戏逻辑 |
| UnityEngine.CoreModule.dll | MonoBehaviour, GameObject, Transform 等 Unity 基础 |
| UnityEngine.PhysicsModule.dll | Rigidbody, Collider, Physics 等物理系统 |

---

## Mod 目录结构

```
Mods/
└── MyMod/
    ├── info.ini              # Mod 元数据（必需）
    ├── MyMod.dll             # 编译后的 DLL（必需）
    └── Assets/               # 资源目录（可选）
        ├── my_assets         # AssetBundle 文件
        └── icons/            # 图标等资源
```

---

## info.ini 配置

```ini
[mod]
name=我的Mod名称
version=1.0.0
author=作者名
description=Mod描述文字
dll=MyMod.dll
```

### 字段说明

| 字段 | 必需 | 说明 |
|------|------|------|
| name | 是 | Mod 显示名称 |
| version | 是 | 版本号 |
| author | 否 | 作者名 |
| description | 否 | Mod 描述 |
| dll | 是 | DLL 文件名 |

---

## ModBehaviour 基类

所有 Mod 必须继承 `Duckov.Modding.ModBehaviour`：

```csharp
using UnityEngine;
using Duckov.Modding;

namespace MyMod
{
    public class MyModBehaviour : ModBehaviour
    {
        void Start()
        {
            Debug.Log("[MyMod] 开始加载...");
            // 初始化代码
        }

        void OnDestroy()
        {
            Debug.Log("[MyMod] 卸载...");
            // 清理代码
        }
    }
}
```

---

## info 对象

`ModBehaviour` 基类提供 `info` 对象，包含 Mod 元数据：

```csharp
public class ModInfo
{
    public string dllPath;      // DLL 文件完整路径
    public string name;         // Mod 名称
    public string version;      // 版本号
    public string author;       // 作者
    public string description;  // 描述
}
```

### 获取 Mod 目录路径

```csharp
/// <summary>
/// 获取 Mod 所在目录路径
/// 用于加载 AssetBundle 等资源
/// </summary>
private string GetModFolderPath()
{
    // 方法1：通过 info.dllPath（推荐）
    if (info != null && !string.IsNullOrEmpty(info.dllPath))
    {
        return System.IO.Path.GetDirectoryName(info.dllPath);
    }

    // 方法2：通过程序集位置（备用）
    string assemblyPath = GetType().Assembly.Location;
    if (!string.IsNullOrEmpty(assemblyPath))
    {
        return System.IO.Path.GetDirectoryName(assemblyPath);
    }

    return string.Empty;
}
```

---

## AssetBundle 加载

### 同步加载

```csharp
private AssetBundle assetBundle;
private Sprite itemIcon;
private GameObject itemPrefab;

private void LoadAssetBundle()
{
    string modFolder = GetModFolderPath();
    string bundlePath = System.IO.Path.Combine(modFolder, "Assets", "my_assets");

    if (!System.IO.File.Exists(bundlePath))
    {
        Debug.LogWarning($"[MyMod] AssetBundle 不存在: {bundlePath}");
        return;
    }

    // 同步加载
    assetBundle = AssetBundle.LoadFromFile(bundlePath);

    if (assetBundle != null)
    {
        // 加载 Prefab
        itemPrefab = assetBundle.LoadAsset<GameObject>("MyItemPrefab");

        // 加载图标
        itemIcon = LoadIconFromBundle("MyItemIcon");

        Debug.Log("[MyMod] AssetBundle 加载成功");
    }
}

private Sprite LoadIconFromBundle(string iconName)
{
    if (assetBundle == null) return null;

    // 尝试直接加载 Sprite
    Sprite icon = assetBundle.LoadAsset<Sprite>(iconName);
    if (icon != null) return icon;

    // 尝试加载 Texture2D 并转换
    Texture2D tex = assetBundle.LoadAsset<Texture2D>(iconName);
    if (tex != null)
    {
        return Sprite.Create(tex,
            new Rect(0, 0, tex.width, tex.height),
            new Vector2(0.5f, 0.5f));
    }

    return null;
}
```

### 卸载 AssetBundle

```csharp
void OnDestroy()
{
    if (assetBundle != null)
    {
        assetBundle.Unload(true);  // true = 卸载所有加载的资源
        assetBundle = null;
    }
}
```

---

## Unity 项目配置（AssetBundle 打包）

### 创建 Unity 项目

1. 使用 Unity 2022.3.x 创建新项目
2. 导入游戏 DLL 到 `Assets/Plugins/`
3. 创建 Prefab 和资源
4. 设置 AssetBundle 名称
5. 打包 AssetBundle

### AssetBundle 打包脚本

```csharp
// Assets/Editor/AssetBundleBuilder.cs
using UnityEditor;
using System.IO;

public class AssetBundleBuilder
{
    [MenuItem("Assets/Build AssetBundles")]
    static void BuildAllAssetBundles()
    {
        string outputPath = "Assets/AssetBundles";
        if (!Directory.Exists(outputPath))
        {
            Directory.CreateDirectory(outputPath);
        }

        BuildPipeline.BuildAssetBundles(
            outputPath,
            BuildAssetBundleOptions.None,
            BuildTarget.StandaloneWindows64  // 目标平台
        );

        Debug.Log("AssetBundle 打包完成: " + outputPath);
    }
}
```

---

## 调试与日志

### 日志输出

```csharp
// 普通日志
Debug.Log("[MyMod] 信息");

// 警告
Debug.LogWarning("[MyMod] 警告");

// 错误
Debug.LogError("[MyMod] 错误");
```

### 查看日志

日志文件位置：
- Windows: `%USERPROFILE%\AppData\LocalLow\TeamSoda\Escape from Duckov\Player.log`

### 调试快捷键

```csharp
void Update()
{
    // F9: 添加测试物品
    if (Input.GetKeyDown(KeyCode.F9))
    {
        AddTestItems();
    }

    // F10: 显示调试信息
    if (Input.GetKeyDown(KeyCode.F10))
    {
        ShowDebugInfo();
    }

    // F11: 恢复生命/体力
    if (Input.GetKeyDown(KeyCode.F11))
    {
        RestorePlayerStats();
    }
}

private void ShowDebugInfo()
{
    var character = CharacterMainControl.Main;
    if (character == null) return;

    var health = character.Health;
    string info = $"HP: {health?.CurrentHealth:F0}/{health?.MaxHealth:F0}\n" +
                  $"Stamina: {character.CurrentStamina:F0}/{character.MaxStamina:F0}\n" +
                  $"Scene: {UnityEngine.SceneManagement.SceneManager.GetActiveScene().name}\n" +
                  $"Position: {character.transform.position}";

    Debug.Log($"[调试信息]\n{info}");
}

private void RestorePlayerStats()
{
    var character = CharacterMainControl.Main;
    if (character == null) return;

    character.Health?.AddHealth(character.Health.MaxHealth);
    character.UseStamina(-character.MaxStamina);

    Debug.Log("[调试] 已恢复玩家状态");
}
```

---

## 常见问题

### DLL 无法加载

1. 检查 info.ini 中的 dll 字段是否正确
2. 确认 DLL 目标框架是 .NET Standard 2.1
3. 检查是否有缺失的依赖

### AssetBundle 加载失败

1. 确认 Unity 版本与游戏一致 (2022.3.x)
2. 确认打包平台是 StandaloneWindows64
3. 检查文件路径是否正确

### 物品不显示

1. 检查 TypeID 是否唯一
2. 确认已调用 ItemAssetsCollection.AddDynamicEntry()
3. 检查本地化文本是否设置
