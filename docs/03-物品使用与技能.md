# 03-物品使用与技能

## UsageBehavior 使用行为系统

### 基类结构

```csharp
// 源码位置: ItemStatsSystem/UsageBehavior.cs
public abstract class UsageBehavior : MonoBehaviour
{
    // 子类必须实现：判断是否可以使用
    public abstract bool CanBeUsed(Item item, object user);

    // 子类必须实现：执行使用逻辑
    protected abstract void OnUse(Item item, object user);

    public void Use(Item item, object user)
    {
        this.OnUse(item, user);
    }
}
```

### UsageUtilities 管理器

```csharp
public class UsageUtilities
{
    public List<UsageBehavior> behaviors;  // 使用行为列表
    public bool useDurability;              // 是否消耗耐久
    public int durabilityUsage;             // 每次消耗的耐久值

    // 检查物品是否可用
    public bool IsUsable(Item item, object user)
    {
        if (!item) return false;

        // 检查耐久度
        if (this.useDurability && item.Durability < (float)this.durabilityUsage)
            return false;

        // 只要有一个行为可用即返回true
        foreach (UsageBehavior behavior in this.behaviors)
        {
            if (behavior != null && behavior.CanBeUsed(item, user))
                return true;
        }
        return false;
    }

    // 执行使用行为
    public void Use(Item item, object user)
    {
        foreach (UsageBehavior behavior in this.behaviors)
        {
            if (behavior != null && behavior.CanBeUsed(item, user))
                behavior.Use(item, user);
        }

        // 消耗耐久度
        if (this.useDurability && item.UseDurability)
            item.Durability -= (float)this.durabilityUsage;

        item.NotifyOnUse(user);
    }
}
```

---

## 常用 UsageBehavior 实现

### 药品 (Drug)

```csharp
public class Drug : UsageBehavior
{
    public int healValue;          // 治疗量
    public bool useDurability;     // 是否消耗耐久
    public float durabilityUsage;  // 消耗量
    public bool canUsePart;        // 是否可部分使用

    public override bool CanBeUsed(Item item, object user)
    {
        CharacterMainControl character = user as CharacterMainControl;
        return character && this.CheckCanHeal(character);
    }

    private bool CheckCanHeal(CharacterMainControl character)
    {
        return this.healValue <= 0 ||
               character.Health.CurrentHealth < character.Health.MaxHealth;
    }

    protected override void OnUse(Item item, object user)
    {
        CharacterMainControl character = user as CharacterMainControl;
        if (!character) return;

        float healAmount = (float)this.healValue;
        this.Heal(character, item, healAmount);
    }
}
```

### 食物饮料 (FoodDrink)

```csharp
public class FoodDrink : UsageBehavior
{
    public float energyValue;   // 能量恢复
    public float waterValue;    // 水分恢复
    public float UseDurability; // 耐久消耗

    public override bool CanBeUsed(Item item, object user)
    {
        return user as CharacterMainControl;
    }

    protected override void OnUse(Item item, object user)
    {
        CharacterMainControl character = user as CharacterMainControl;
        if (!character) return;

        if (this.energyValue != 0f) character.AddEnergy(this.energyValue);
        if (this.waterValue != 0f) character.AddWater(this.waterValue);

        if (this.UseDurability > 0f && item.UseDurability)
            item.Durability -= this.UseDurability;
    }
}
```

### Buff药剂 (AddBuff)

```csharp
public class AddBuff : UsageBehavior
{
    public Buff buffPrefab;           // Buff预制体
    [Range(0.01f, 1f)]
    public float chance = 1f;         // 生效概率

    public override bool CanBeUsed(Item item, object user)
    {
        return true;  // Buff药剂总是可用的
    }

    protected override void OnUse(Item item, object user)
    {
        CharacterMainControl character = user as CharacterMainControl;
        if (character == null) return;

        // 概率检查
        if (UnityEngine.Random.Range(0f, 1f) > this.chance) return;

        character.AddBuff(this.buffPrefab, character, 0);
    }
}
```

---

## 自定义 UsageBehavior

```csharp
using UnityEngine;
using ItemStatsSystem;
using Duckov;

namespace MyMod
{
    public class MyCustomUsage : UsageBehavior
    {
        public int effectValue = 50;
        public bool requireFullHealth = false;

        public override bool CanBeUsed(Item item, object user)
        {
            CharacterMainControl character = user as CharacterMainControl;
            if (character == null) return false;

            // 自定义条件判断
            if (requireFullHealth &&
                character.Health.CurrentHealth < character.Health.MaxHealth)
            {
                return false;
            }

            return true;
        }

        protected override void OnUse(Item item, object user)
        {
            CharacterMainControl character = user as CharacterMainControl;
            if (character == null) return;

            // 执行自定义效果
            Debug.Log($"[MyMod] 使用物品效果: {effectValue}");

            // 示例：恢复体力
            character.UseStamina(-effectValue);
        }
    }
}
```

---

## SkillBase 技能系统

### 技能基类

```csharp
public class SkillBase : MonoBehaviour
{
    // 技能配置
    protected SkillContext skillContext;           // 技能上下文
    protected SkillReleaseContext skillReleaseContext;  // 释放上下文
    protected CharacterMainControl fromCharacter;   // 使用者

    // 子类重写：技能释放时调用
    public virtual void OnRelease() { }

    // 子类重写：技能取消时调用
    public virtual void OnCancel() { }

    // 子类重写：技能更新
    public virtual void OnUpdate() { }
}
```

### SkillContext 配置参数

```csharp
public class SkillContext
{
    public float castRange;           // 技能范围
    public float cooldown;            // 冷却时间
    public float castTime;            // 施法时间
    public bool canMove;              // 施法时能否移动
    public bool canRotate;            // 施法时能否旋转
    public float staminaCost;         // 体力消耗
    public LayerMask targetLayers;    // 目标层级
}
```

### SkillReleaseContext 运行时数据

```csharp
public class SkillReleaseContext
{
    public Vector3 releasePoint;      // 释放点（鼠标位置/目标位置）
    public Vector3 releaseDirection;  // 释放方向
    public Transform target;          // 目标Transform
    public float chargeRatio;         // 蓄力比例（0-1）
}
```

---

## 自定义技能实现

### 投掷物技能示例

```csharp
using UnityEngine;
using Duckov;
using ItemStatsSystem;

namespace MyMod
{
    public class WormholeGrenadeSkill : SkillBase
    {
        public float damageRange = 16f;
        public float delayTime = 3f;
        public float throwForce = 15f;
        public float throwAngle = 30f;
        public float grenadeVerticleSpeed = 10f;
        public bool canHurtSelf = true;

        public override void OnRelease()
        {
            if (fromCharacter == null)
            {
                Debug.LogWarning("[技能] 没有使用者");
                return;
            }

            // 获取投掷位置和方向
            Vector3 position = fromCharacter.CurrentUsingAimSocket.position;
            Vector3 releasePoint = skillReleaseContext.releasePoint;

            // 计算投掷方向
            Vector3 point = releasePoint - fromCharacter.transform.position;
            point.y = 0;
            float castDistance = point.magnitude;
            point.Normalize();

            // 投掷手雷
            ThrowGrenade(position, point, castDistance, releasePoint.y);
        }

        private void ThrowGrenade(Vector3 position, Vector3 direction,
            float distance, float height)
        {
            Vector3 target = position + direction * distance;
            target.y = height;

            // 创建投掷物
            GameObject grenadeObj = new GameObject("MyGrenade");
            grenadeObj.transform.position = position;

            // 添加投掷物组件
            MyGrenadeProjectile projectile =
                grenadeObj.AddComponent<MyGrenadeProjectile>();
            projectile.delayTime = delayTime;
            projectile.damageRange = damageRange;

            // 计算投掷速度
            Vector3 velocity = CalculateVelocity(position, target, grenadeVerticleSpeed);
            projectile.Launch(position, velocity, fromCharacter, canHurtSelf);
        }

        /// <summary>
        /// 计算抛物线投掷速度
        /// </summary>
        private Vector3 CalculateVelocity(Vector3 start, Vector3 target, float verticleSpeed)
        {
            float g = Physics.gravity.magnitude;
            float y = target.y - start.y;
            Vector3 vector = target - start;
            vector.y = 0f;
            float num = vector.magnitude;
            float num2 = Mathf.Sqrt(y * y + num * num);
            float num3 = num2 + y;
            float num4 = num2 - y;
            float t = 2f * num3 / (g * num4);
            float num5 = num / Mathf.Sqrt(t);
            float num6 = g * t / 2f;
            Vector3 result = vector.normalized * num5;
            result.y = num6;
            return result;
        }
    }
}
```

---

## 将技能绑定到物品

### 使用 DisplaySettings

```csharp
public class DisplaySettings
{
    public SkillBase skill;           // 技能组件
    public float holdTime;            // 长按时间
    public bool showIndicator;        // 显示指示器
    public float indicatorRange;      // 指示器范围
}
```

### 在 ModBehaviour 中配置

```csharp
private void SetupSkillItem(Item item)
{
    // 获取 DisplaySettings
    var displaySettings = item.GetComponent<DisplaySettings>();
    if (displaySettings == null)
    {
        displaySettings = item.gameObject.AddComponent<DisplaySettings>();
    }

    // 添加技能组件
    var skill = item.gameObject.AddComponent<WormholeGrenadeSkill>();
    skill.damageRange = 16f;
    skill.delayTime = 3f;

    // 绑定到 DisplaySettings
    displaySettings.skill = skill;
    displaySettings.holdTime = 0.5f;
    displaySettings.showIndicator = true;
    displaySettings.indicatorRange = 15f;
}
```

---

## 消耗品完整示例

### Prefab 结构

```
MyConsumableItem (GameObject)
├── Item (Component)
│   ├── TypeID: 990001
│   ├── DisplayName: "自定义消耗品"
│   ├── MaxStackCount: 10
│   ├── Stackable: true
│   └── UsageUtilities
│       ├── useDurability: false
│       └── behaviors: [MyCustomUsage]
│
└── MyCustomUsage (Component)
    ├── effectValue: 50
    └── requireFullHealth: false
```

### 代码实现

```csharp
private Item CreateConsumableItem()
{
    // 1. 创建 GameObject
    GameObject obj = new GameObject("MyConsumableItem");
    DontDestroyOnLoad(obj);
    obj.SetActive(false);

    // 2. 添加 Item 组件
    Item item = obj.AddComponent<Item>();
    SetFieldValue(item, "typeID", 990001);
    SetFieldValue(item, "displayName", "MyItem_Name");
    SetFieldValue(item, "description", "MyItem_Desc");
    SetFieldValue(item, "stackable", true);
    SetFieldValue(item, "maxStackCount", 10);

    // 3. 添加使用行为
    MyCustomUsage usage = obj.AddComponent<MyCustomUsage>();
    usage.effectValue = 50;

    // 4. 配置 UsageUtilities（反射）
    var usageUtils = new UsageUtilities();
    usageUtils.behaviors = new List<UsageBehavior> { usage };
    usageUtils.useDurability = false;
    SetFieldValue(item, "usageUtilities", usageUtils);

    return item;
}
```

---

## 常见问题

### 物品无法使用

1. 检查 `UsageUtilities.behaviors` 是否包含 `UsageBehavior`
2. 检查 `CanBeUsed()` 返回值
3. 检查耐久度是否足够

### 技能无法释放

1. 检查 `DisplaySettings.skill` 是否设置
2. 检查 `fromCharacter` 是否为空
3. 确认物品已正确绑定到角色

### 技能范围指示器不显示

1. 确认 `showIndicator = true`
2. 检查 `indicatorRange` 是否 > 0
3. 确认物品持有状态正确
