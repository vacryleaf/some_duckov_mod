# 07-场景与撤离系统

## LevelManager 关卡管理器

### 获取实例

```csharp
// 获取关卡管理器实例
LevelManager levelManager = LevelManager.Instance;

// 常用属性
CharacterMainControl player = LevelManager.Instance.MainCharacter;  // 主角
CharacterMainControl pet = LevelManager.Instance.PetCharacter;       // 宠物
Camera gameCamera = LevelManager.Instance.GameCamera;                 // 游戏相机
```

### 关卡事件

```csharp
// 关卡生命周期事件
public static event Action OnLevelBeginInitializing;  // 关卡开始初始化
public static event Action OnLevelInitialized;        // 关卡初始化完成
public static event Action OnAfterLevelInitialized;   // 关卡初始化后

// 游戏状态事件
public static event Action OnEvacuated;               // 撤离成功
public static event Action OnMainCharacterDead;       // 主角死亡

// 使用示例
void Start()
{
    LevelManager.OnLevelInitialized += OnLevelReady;
    LevelManager.OnEvacuated += OnPlayerEvacuated;
    LevelManager.OnMainCharacterDead += OnPlayerDead;
}

void OnDestroy()
{
    LevelManager.OnLevelInitialized -= OnLevelReady;
    LevelManager.OnEvacuated -= OnPlayerEvacuated;
    LevelManager.OnMainCharacterDead -= OnPlayerDead;
}

void OnLevelReady()
{
    Debug.Log("关卡已加载，可以访问主角了");
    var player = LevelManager.Instance.MainCharacter;
}

void OnPlayerEvacuated()
{
    Debug.Log("玩家成功撤离");
}

void OnPlayerDead()
{
    Debug.Log("玩家死亡");
}
```

---

## SceneLoader 场景加载器

### 获取实例

```csharp
// 通过 GameManager 获取
SceneLoader sceneLoader = GameManager.SceneLoader;
```

### 场景加载方法

```csharp
// 加载场景（使用反射调用）
private void LoadScene(string sceneName)
{
    var sceneLoader = GameManager.SceneLoader;
    if (sceneLoader == null) return;

    // 使用反射调用 LoadScene 方法
    var loadMethod = sceneLoader.GetType().GetMethod("LoadScene",
        BindingFlags.Public | BindingFlags.Instance);

    loadMethod?.Invoke(sceneLoader, new object[] { sceneName });
}
```

### 常用场景名称

| 场景名 | 说明 |
|--------|------|
| MainMenu | 主菜单 |
| Hideout | 藏身处 |
| Factory | 工厂地图 |
| Woods | 森林地图 |
| Customs | 海关地图 |

---

## 撤离系统

### 撤离点结构

```csharp
public class ExtractionPoint : MonoBehaviour
{
    public string pointName;           // 撤离点名称
    public float extractionTime;       // 撤离所需时间
    public bool requiresItem;          // 是否需要物品
    public int requiredItemTypeId;     // 需要的物品 TypeID
    public bool isOpen;                // 是否开放
}
```

### 监听撤离事件

```csharp
void Start()
{
    LevelManager.OnEvacuated += OnEvacuated;
}

void OnEvacuated()
{
    // 撤离成功时的逻辑
    Debug.Log("撤离成功！");

    // 可以在这里保存数据、发放奖励等
    SaveModData();
    GiveEvacuationReward();
}

void OnDestroy()
{
    LevelManager.OnEvacuated -= OnEvacuated;
}
```

---

## 跨场景数据传递

### 使用 SavesSystem

```csharp
// 保存跨场景数据
void SaveCrossSceneData()
{
    // 保存到当前存档
    SavesSystem.Save("MyMod_CrossSceneData", myData);
}

// 加载跨场景数据
void LoadCrossSceneData()
{
    myData = SavesSystem.Load("MyMod_CrossSceneData", new MyData());
}

// 使用全局数据（不随存档槽改变）
void SaveGlobalData()
{
    SavesSystem.SaveGlobal("MyMod_GlobalSettings", settings);
}

void LoadGlobalData()
{
    settings = SavesSystem.LoadGlobal("MyMod_GlobalSettings", new Settings());
}
```

### 使用静态变量（临时数据）

```csharp
public static class CrossSceneData
{
    public static int LastMapScore;
    public static List<int> CollectedItems = new List<int>();
    public static bool HasSpecialItem;

    public static void Clear()
    {
        LastMapScore = 0;
        CollectedItems.Clear();
        HasSpecialItem = false;
    }
}

// 使用示例
void OnEvacuated()
{
    CrossSceneData.LastMapScore = CalculateScore();
}

void OnLevelReady()
{
    if (CrossSceneData.HasSpecialItem)
    {
        // 根据上一关的状态执行逻辑
        ApplySpecialEffect();
    }
}
```

---

## 场景切换时的数据保持

### 使用 DontDestroyOnLoad

```csharp
public class PersistentModData : MonoBehaviour
{
    public static PersistentModData Instance { get; private set; }

    public int persistentValue;
    public List<string> collectedItems = new List<string>();

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

### 场景加载回调

```csharp
using UnityEngine.SceneManagement;

void Start()
{
    SceneManager.sceneLoaded += OnSceneLoaded;
}

void OnDestroy()
{
    SceneManager.sceneLoaded -= OnSceneLoaded;
}

void OnSceneLoaded(Scene scene, LoadSceneMode mode)
{
    Debug.Log($"场景加载完成: {scene.name}");

    // 根据场景执行不同逻辑
    switch (scene.name)
    {
        case "Hideout":
            OnHideoutLoaded();
            break;
        case "Factory":
        case "Woods":
        case "Customs":
            OnRaidMapLoaded();
            break;
    }
}

void OnHideoutLoaded()
{
    // 藏身处加载时的逻辑
    Debug.Log("进入藏身处");
}

void OnRaidMapLoaded()
{
    // 战斗地图加载时的逻辑
    Debug.Log("进入战斗地图");
}
```

---

## 传送功能实现

### 简单传送

```csharp
/// <summary>
/// 将玩家传送到指定位置
/// </summary>
public void TeleportPlayer(Vector3 targetPosition)
{
    var player = LevelManager.Instance?.MainCharacter;
    if (player == null) return;

    player.transform.position = targetPosition;
    Debug.Log($"玩家传送到: {targetPosition}");
}
```

### 带特效的传送

```csharp
using System.Collections;

public IEnumerator TeleportWithEffect(Vector3 targetPosition)
{
    var player = LevelManager.Instance?.MainCharacter;
    if (player == null) yield break;

    // 1. 播放消失特效
    CreateTeleportEffect(player.transform.position, Color.blue);

    // 2. 短暂延迟
    yield return new WaitForSeconds(0.3f);

    // 3. 执行传送
    player.transform.position = targetPosition;

    // 4. 播放出现特效
    CreateTeleportEffect(targetPosition, Color.cyan);

    Debug.Log($"传送完成: {targetPosition}");
}

private void CreateTeleportEffect(Vector3 position, Color color)
{
    GameObject effectObj = new GameObject("TeleportEffect");
    effectObj.transform.position = position;

    Light light = effectObj.AddComponent<Light>();
    light.type = LightType.Point;
    light.color = color;
    light.intensity = 5f;
    light.range = 3f;

    Destroy(effectObj, 0.5f);
}
```

---

## 场景条件判断

```csharp
/// <summary>
/// 检查当前是否在战斗地图
/// </summary>
public bool IsInRaidMap()
{
    string sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;

    return sceneName != "MainMenu" &&
           sceneName != "Hideout" &&
           sceneName != "Loading";
}

/// <summary>
/// 检查当前是否在藏身处
/// </summary>
public bool IsInHideout()
{
    string sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
    return sceneName == "Hideout";
}

/// <summary>
/// 获取当前场景名称
/// </summary>
public string GetCurrentSceneName()
{
    return UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
}
```

---

## 完整场景管理示例

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using Duckov;
using Duckov.Modding;

namespace MyMod
{
    public class SceneManagement : ModBehaviour
    {
        private bool isInRaid = false;
        private float raidStartTime;

        void Start()
        {
            // 注册事件
            LevelManager.OnLevelInitialized += OnLevelReady;
            LevelManager.OnEvacuated += OnEvacuated;
            LevelManager.OnMainCharacterDead += OnPlayerDead;
            SceneManager.sceneLoaded += OnSceneLoaded;
        }

        void OnDestroy()
        {
            // 取消注册
            LevelManager.OnLevelInitialized -= OnLevelReady;
            LevelManager.OnEvacuated -= OnEvacuated;
            LevelManager.OnMainCharacterDead -= OnPlayerDead;
            SceneManager.sceneLoaded -= OnSceneLoaded;
        }

        void OnSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            Debug.Log($"[MyMod] 场景切换: {scene.name}");
        }

        void OnLevelReady()
        {
            string sceneName = SceneManager.GetActiveScene().name;

            if (sceneName != "Hideout" && sceneName != "MainMenu")
            {
                // 进入战斗地图
                isInRaid = true;
                raidStartTime = Time.time;
                Debug.Log("[MyMod] 开始战斗");
            }
            else
            {
                isInRaid = false;
            }
        }

        void OnEvacuated()
        {
            if (isInRaid)
            {
                float raidDuration = Time.time - raidStartTime;
                Debug.Log($"[MyMod] 撤离成功，用时: {raidDuration:F1}秒");

                // 保存战斗数据
                SaveRaidData(raidDuration);
            }
            isInRaid = false;
        }

        void OnPlayerDead()
        {
            if (isInRaid)
            {
                Debug.Log("[MyMod] 战斗失败");
                // 可以在这里处理死亡惩罚
            }
            isInRaid = false;
        }

        private void SaveRaidData(float duration)
        {
            int totalRaids = SavesSystem.Load("MyMod_TotalRaids", 0);
            float totalTime = SavesSystem.Load("MyMod_TotalRaidTime", 0f);

            SavesSystem.Save("MyMod_TotalRaids", totalRaids + 1);
            SavesSystem.Save("MyMod_TotalRaidTime", totalTime + duration);
        }
    }
}
```

---

## 常见问题

### 场景事件不触发

1. 确认事件在正确的时机注册（Start 中）
2. 检查 `OnDestroy` 中是否正确取消注册
3. 确认场景名称拼写正确

### 跨场景数据丢失

1. 使用 `SavesSystem` 保存重要数据
2. 使用 `DontDestroyOnLoad` 保持对象
3. 避免只依赖静态变量存储重要数据

### 传送后位置异常

1. 检查目标位置是否有效（不在墙内）
2. 确认玩家角色存在且可访问
3. 考虑添加位置校验逻辑
