# 04-效果系统

## Effect 组件结构

```csharp
// 源码位置: ItemStatsSystem/Effect.cs
public class Effect : MonoBehaviour
{
    [SerializeField] private Item item;                    // 所属物品
    [SerializeField] private bool display;                 // 是否显示效果描述
    [SerializeField] private string description;           // 效果描述

    internal List<EffectTrigger> triggers;  // 触发器列表
    internal List<EffectFilter> filters;    // 过滤器列表
    internal List<EffectAction> actions;    // 动作列表

    // 触发效果（由Trigger调用）
    internal void Trigger(EffectTriggerEventContext context)
    {
        if (!this.enabled) return;
        if (!this.gameObject.activeInHierarchy) return;

        // 通过所有过滤器检查
        if (!this.EvaluateFilters(context)) return;

        // 执行所有动作
        foreach (EffectAction action in this.actions)
        {
            action.NotifyTriggered(context);
        }
    }
}
```

---

## EffectTrigger 触发器

### 基类

```csharp
public class EffectTrigger : EffectComponent
{
    // 触发效果（positive=true为正向触发，false为负向/取消）
    protected void Trigger(bool positive = true)
    {
        base.Master.Trigger(new EffectTriggerEventContext(this, positive));
    }

    // 当Effect设置目标Item时调用
    protected virtual void OnMasterSetTargetItem(Effect effect, Item item) { }

    // 禁用时自动触发负向效果
    protected virtual void OnDisable()
    {
        this.Trigger(false);
    }
}
```

### 物品使用触发器

```csharp
public class ItemUsedTrigger : EffectTrigger
{
    public override string DisplayName => "当物品被使用";

    private void OnEnable()
    {
        if (base.Master?.Item != null)
        {
            base.Master.Item.onUse += this.OnItemUsed;
        }
    }

    private void OnDisable()
    {
        base.Master?.Item?.onUse -= this.OnItemUsed;
    }

    private void OnItemUsed(Item item, object user)
    {
        base.Trigger(true);
    }
}
```

### 射击/攻击触发器

```csharp
[MenuPath("General/On Shoot&Attack")]
public class OnShootAttackTrigger : EffectTrigger
{
    [SerializeField] private bool onShoot = true;
    [SerializeField] private bool onAttack = true;
    private CharacterMainControl target;

    private void OnEnable() { this.RegisterEvents(); }
    protected override void OnDisable() { base.OnDisable(); this.UnregisterEvents(); }

    private void RegisterEvents()
    {
        this.UnregisterEvents();

        Item item = base.Master?.Item;
        if (item == null) return;

        this.target = item.GetCharacterMainControl();
        if (this.target == null) return;

        if (this.onShoot) this.target.OnShootEvent += this.OnShootAttack;
        if (this.onAttack) this.target.OnAttackEvent += this.OnShootAttack;
    }

    private void OnShootAttack(DuckovItemAgent agent)
    {
        base.Trigger(true);
    }
}
```

### 受伤触发器

```csharp
[MenuPath("General/On Take Damage")]
public class OnTakeDamageTrigger : EffectTrigger
{
    [SerializeField] public int threshold;  // 伤害阈值
    private Health target;

    private void RegisterEvents()
    {
        Item item = base.Master?.Item;
        CharacterMainControl character = item?.GetCharacterMainControl();
        if (character == null) return;

        this.target = character.Health;
        this.target.OnHurtEvent.AddListener(this.OnTookDamage);
    }

    private void OnTookDamage(DamageInfo info)
    {
        if (info.damageValue < (float)this.threshold) return;
        base.Trigger(true);
    }
}
```

### 周期触发器

```csharp
public class TickTrigger : EffectTrigger, IUpdatable
{
    [SerializeField] private float period = 1f;           // 触发周期（秒）
    [SerializeField] private bool allowMultipleTrigger;   // 是否允许单帧多次触发
    private float buffer;

    public override string DisplayName => $"每{this.period}秒";

    private void OnEnable() { UpdatableInvoker.Register(this); }
    private void OnDisable() { UpdatableInvoker.Unregister(this); }

    public void OnUpdate()
    {
        this.buffer += Time.deltaTime / this.period;
        while (this.buffer > 1f)
        {
            this.buffer -= 1f;
            base.Trigger(true);
            if (!this.allowMultipleTrigger) break;
        }
    }
}
```

---

## EffectAction 动作

### 基类

```csharp
public class EffectAction : EffectComponent
{
    internal void NotifyTriggered(EffectTriggerEventContext context)
    {
        if (!this.enabled) return;

        this.OnTriggered(context.positive);

        if (context.positive)
            this.OnTriggeredPositive();
        else
            this.OnTriggeredNegative();
    }

    protected virtual void OnTriggered(bool positive) { }
    protected virtual void OnTriggeredPositive() { }
    protected virtual void OnTriggeredNegative() { }
}
```

### 属性修改动作

```csharp
public class ModifierAction : EffectAction
{
    public string targetStatKey;          // 目标属性名
    public ModifierType ModifierType;     // 修改类型
    public float modifierValue;           // 修改值
    private Modifier modifier;
    private Stat targetStat;

    protected override void Awake()
    {
        base.Awake();
        this.modifier = new Modifier(
            this.ModifierType,
            this.modifierValue,
            this.overrideOrder,
            this.overrideOrderValue,
            base.Master
        );
    }

    protected override void OnTriggered(bool positive)
    {
        Item characterItem = base.Master.Item?.GetCharacterItem();
        if (characterItem == null) return;

        if (positive)
        {
            this.targetStat?.RemoveModifier(this.modifier);
            this.targetStat = characterItem.GetStat(this.targetStatKey.GetHashCode());
            this.targetStat.AddModifier(this.modifier);
        }
        else
        {
            this.targetStat?.RemoveModifier(this.modifier);
            this.targetStat = null;
        }
    }
}
```

### 添加 Buff 动作

```csharp
public class AddBuffAction : EffectAction
{
    public Buff buffPfb;

    private CharacterMainControl MainControl =>
        base.Master?.Item?.GetCharacterMainControl();

    protected override void OnTriggered(bool positive)
    {
        if (!this.MainControl) return;
        this.MainControl.AddBuff(this.buffPfb, this.MainControl, 0);
    }
}
```

### 治疗动作

```csharp
public class HealAction : EffectAction
{
    public int healValue = 10;

    protected override void OnTriggered(bool positive)
    {
        CharacterMainControl mainControl = base.Master?.Item?.GetCharacterMainControl();
        if (!mainControl) return;
        mainControl.Health.AddHealth((float)this.healValue);
    }
}
```

---

## 自定义 EffectTrigger

```csharp
using UnityEngine;
using ItemStatsSystem;
using Duckov;

namespace MyMod
{
    /// <summary>
    /// 自定义触发器：当玩家体力低于阈值时触发
    /// </summary>
    public class LowStaminaTrigger : EffectTrigger, IUpdatable
    {
        [SerializeField] private float staminaThreshold = 20f;
        private CharacterMainControl character;
        private bool wasTriggered = false;

        public override string DisplayName => $"当体力低于{staminaThreshold}";

        private void OnEnable()
        {
            character = base.Master?.Item?.GetCharacterMainControl();
            UpdatableInvoker.Register(this);
        }

        protected override void OnDisable()
        {
            UpdatableInvoker.Unregister(this);
            base.OnDisable();
        }

        public void OnUpdate()
        {
            if (character == null) return;

            bool isLow = character.CurrentStamina < staminaThreshold;

            if (isLow && !wasTriggered)
            {
                wasTriggered = true;
                base.Trigger(true);  // 正向触发
            }
            else if (!isLow && wasTriggered)
            {
                wasTriggered = false;
                base.Trigger(false); // 负向触发（取消效果）
            }
        }
    }
}
```

---

## 自定义 EffectAction

```csharp
using UnityEngine;
using ItemStatsSystem;
using Duckov;

namespace MyMod
{
    /// <summary>
    /// 自定义动作：恢复体力
    /// </summary>
    public class RestoreStaminaAction : EffectAction
    {
        [SerializeField] private float staminaAmount = 20f;

        protected override void OnTriggeredPositive()
        {
            CharacterMainControl character = base.Master?.Item?.GetCharacterMainControl();
            if (character == null) return;

            // 恢复体力（负值表示增加）
            character.UseStamina(-staminaAmount);
            Debug.Log($"[MyMod] 恢复体力: {staminaAmount}");
        }

        protected override void OnTriggeredNegative()
        {
            // 负向触发时可以执行取消逻辑（可选）
            Debug.Log("[MyMod] 效果取消");
        }
    }
}
```

---

## 在物品上配置 Effect 系统

### 代码配置

```csharp
private void SetupItemEffect(Item itemPrefab)
{
    // 1. 创建 Effect 子对象
    GameObject effectObj = new GameObject("Effect_MyEffect");
    effectObj.transform.SetParent(itemPrefab.transform);

    // 2. 添加 Effect 组件
    Effect effect = effectObj.AddComponent<Effect>();

    // 3. 添加触发器
    LowStaminaTrigger trigger = effectObj.AddComponent<LowStaminaTrigger>();

    // 4. 添加动作
    RestoreStaminaAction action = effectObj.AddComponent<RestoreStaminaAction>();

    // 5. 使用反射设置 Effect 的列表
    var triggersField = typeof(Effect).GetField("triggers",
        BindingFlags.NonPublic | BindingFlags.Instance);
    var actionsField = typeof(Effect).GetField("actions",
        BindingFlags.NonPublic | BindingFlags.Instance);

    triggersField?.SetValue(effect, new List<EffectTrigger> { trigger });
    actionsField?.SetValue(effect, new List<EffectAction> { action });
}
```

---

## 被动装备实现模式

被动装备（如徽章、护符）使用 Effect 系统实现被动效果：

```csharp
private void CreatePassiveEquipment()
{
    // 1. 创建物品
    Item item = CreateItemPrefab("MyBadge", 990010, "Badge_Name", "Badge_Desc", null);

    // 2. 配置为装备类型
    SetFieldValue(item, "equipable", true);

    // 3. 添加被动效果
    GameObject effectObj = new GameObject("PassiveEffect");
    effectObj.transform.SetParent(item.transform);

    Effect effect = effectObj.AddComponent<Effect>();

    // 4. 使用 TickTrigger 实现周期性效果
    TickTrigger trigger = effectObj.AddComponent<TickTrigger>();
    SetFieldValue(trigger, "period", 5f);  // 每5秒触发

    // 5. 添加治疗动作
    HealAction healAction = effectObj.AddComponent<HealAction>();
    healAction.healValue = 5;  // 每次恢复5点

    // 6. 注册 Effect
    ConfigureEffect(effect, new[] { trigger }, new EffectAction[] { healAction });
}
```

---

## Effect 生效条件

```
Effect 生效需要满足以下条件：
1. Effect 组件 enabled = true
2. GameObject.activeInHierarchy = true
3. 至少一个 Trigger
4. 至少一个 Action
5. 所有 Filter 通过检查（如果有的话）
6. Trigger 正确注册到对应事件
```

---

## 触发器注册时机

| 触发器 | 注册时机 | 注册的事件 |
|--------|----------|------------|
| ItemUsedTrigger | OnEnable | Item.onUse |
| OnShootAttackTrigger | OnEnable | CharacterMainControl.OnShootEvent/OnAttackEvent |
| OnTakeDamageTrigger | OnEnable | Health.OnHurtEvent |
| TickTrigger | OnEnable | UpdatableInvoker（每帧更新） |

---

## Modifier 修改器类型

```csharp
public enum ModifierType
{
    FlatAdd,        // 1. 先加法 (+10)
    PercentAdd,     // 2. 再百分比加法 (+10%)
    PercentMult,    // 3. 最后百分比乘法 (*1.1)
    Override        // 特殊：直接覆盖
}

// 计算公式：
// FinalValue = (BaseValue + FlatAdd) * (1 + PercentAdd) * PercentMult

// 示例：基础伤害100，+20平加，+10%百分比加，*1.5乘法
// = (100 + 20) * (1 + 0.1) * 1.5 = 198
```

---

## 常见问题

### 效果不触发

1. 检查 `Effect.enabled` 是否为 true
2. 检查 `triggers` 列表是否为空
3. 检查 Trigger 的 `OnEnable` 是否被调用
4. 检查 `actions` 列表是否为空
5. 检查 Filter 是否阻止了触发

### 属性修改无效

1. 确认 `targetStatKey` 正确
2. 检查 `ModifierType` 选择是否合适
3. 确认物品已装备到角色

### 周期效果不稳定

1. 确认正确注册到 `UpdatableInvoker`
2. 检查 `OnDisable` 时是否正确取消注册
