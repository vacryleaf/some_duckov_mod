# 05-战斗与武器系统

## Health 生命值组件

```csharp
// Health 重要属性
public float MaxHealth;              // 最大生命值
public float CurrentHealth;          // 当前生命值
public bool IsDead;                  // 是否死亡
public bool Invincible;              // 是否无敌
public float BodyArmor;              // 身体护甲
public float HeadArmor;              // 头部护甲

// Health 重要事件
public UnityEvent<DamageInfo> OnHurtEvent;     // 受伤事件
public UnityEvent<DamageInfo> OnDeadEvent;     // 死亡事件
public UnityEvent<Health> OnHealthChange;      // 血量变化事件
public UnityEvent<Health> OnMaxHealthChange;   // 最大血量变化事件

// 常用方法
health.AddHealth(50f);                         // 恢复生命值
health.SetHealth(100f);                        // 设置生命值
health.SetInvincible(true);                    // 设置无敌
health.Hurt(damageInfo);                       // 造成伤害
```

---

## DamageInfo 伤害信息

### 创建伤害信息

```csharp
// 创建伤害信息
DamageInfo damageInfo = new DamageInfo();
damageInfo.damageValue = 100f;                  // 伤害值
damageInfo.damageType = DamageTypes.physics;    // 伤害类型
damageInfo.fromCharacter = attacker;            // 伤害来源
damageInfo.hitPoint = hitPosition;              // 命中点
damageInfo.isCritical = false;                  // 是否暴击
damageInfo.elementType = ElementTypes.physics;  // 元素类型

// 完整构造函数
DamageInfo dmgInfo = new DamageInfo(fromCharacter);
dmgInfo.damageValue = 50f;
dmgInfo.damageType = DamageTypes.normal;
```

### 元素类型

```csharp
public enum ElementTypes
{
    physics,      // 物理伤害
    fire,         // 火焰伤害
    poison,       // 毒素伤害
    electricity,  // 电击伤害
    space         // 空间伤害
}
```

### 伤害类型

```csharp
public enum DamageTypes
{
    normal,       // 普通伤害
    physics,      // 物理伤害
    explosion,    // 爆炸伤害
    fall,         // 坠落伤害
    environment   // 环境伤害
}
```

---

## 近战武器系统

### 近战武器核心属性

```csharp
// 通过 Stats 配置的属性
private static readonly int DamageHash = "Damage".GetHashCode();
private static readonly int CritRateHash = "CritRate".GetHashCode();
private static readonly int AttackRangeHash = "AttackRange".GetHashCode();
private static readonly int StaminaCostHash = "StaminaCost".GetHashCode();

public float Damage => item.GetStatValue(DamageHash);
public float CritRate => item.GetStatValue(CritRateHash);
public float AttackRange => item.GetStatValue(AttackRangeHash);
public float StaminaCost => item.GetStatValue(StaminaCostHash);
```

### 自定义攻击逻辑

```csharp
using UnityEngine;
using Duckov;
using ItemStatsSystem;

namespace MyMod
{
    public class MoonlightSwordAttack : MonoBehaviour
    {
        private Item item;
        private CharacterMainControl character;

        // Stats Hash 缓存
        private static readonly int DamageHash = "Damage".GetHashCode();
        private static readonly int CritRateHash = "CritRate".GetHashCode();
        private static readonly int AttackRangeHash = "AttackRange".GetHashCode();

        // 属性访问器
        public float Damage => item != null ? item.GetStatValue(DamageHash) : 80f;
        public float CritRate => item != null ? item.GetStatValue(CritRateHash) : 0.15f;
        public float AttackRange => item != null ? item.GetStatValue(AttackRangeHash) : 2.5f;

        void Start()
        {
            item = GetComponent<Item>();
        }

        /// <summary>
        /// 执行近战攻击
        /// </summary>
        public void PerformAttack(CharacterMainControl attacker)
        {
            character = attacker;

            // 1. 创建伤害信息
            DamageInfo dmgInfo = new DamageInfo(character);
            dmgInfo.damageValue = Damage;
            dmgInfo.damageType = DamageTypes.physics;

            // 2. 暴击判定
            if (Random.value < CritRate)
            {
                dmgInfo.isCritical = true;
                dmgInfo.damageValue *= 2f;
            }

            // 3. 范围检测
            Vector3 attackOrigin = character.transform.position;
            Collider[] hits = Physics.OverlapSphere(attackOrigin, AttackRange);

            foreach (Collider hit in hits)
            {
                // 跳过自己
                if (hit.transform.root == character.transform) continue;

                // 获取伤害接收器
                DamageReceiver receiver = hit.GetComponent<DamageReceiver>();
                if (receiver != null)
                {
                    dmgInfo.hitPoint = hit.ClosestPoint(attackOrigin);
                    receiver.TakeDamage(dmgInfo);
                }
            }
        }
    }
}
```

---

## 连击系统实现

### 连击索引管理

```csharp
public class ComboAttack : MonoBehaviour
{
    private int comboIndex = 0;
    private float lastAttackTime = 0f;
    private float comboResetTime = 1.5f;  // 连击重置时间
    private int maxCombo = 3;

    public void Attack()
    {
        // 检查连击是否超时
        if (Time.time - lastAttackTime > comboResetTime)
        {
            comboIndex = 0;
        }

        // 执行当前连击段
        ExecuteCombo(comboIndex);

        // 更新连击状态
        comboIndex = (comboIndex + 1) % maxCombo;
        lastAttackTime = Time.time;
    }

    private void ExecuteCombo(int index)
    {
        switch (index)
        {
            case 0:
                // 第一段：横斩
                Debug.Log("连击第1段");
                break;
            case 1:
                // 第二段：上挑
                Debug.Log("连击第2段");
                break;
            case 2:
                // 第三段：重击
                Debug.Log("连击第3段");
                break;
        }
    }
}
```

### 协程控制攻击时序

```csharp
private IEnumerator AttackCoroutine()
{
    isAttacking = true;

    // 1. 播放起手动画
    PlayAnimation("Attack_Start");
    yield return new WaitForSeconds(0.2f);

    // 2. 造成伤害
    PerformDamage();

    // 3. 播放收招动画
    PlayAnimation("Attack_End");
    yield return new WaitForSeconds(0.3f);

    isAttacking = false;
}
```

---

## 冲刺移动实现

```csharp
using UnityEngine;
using System.Collections;
using Duckov;

namespace MyMod
{
    public class DashMovement : MonoBehaviour
    {
        public float dashDistance = 5f;
        public float dashDuration = 0.2f;

        private CharacterMainControl character;

        /// <summary>
        /// 执行冲刺
        /// </summary>
        public void PerformDash(Vector3 direction)
        {
            if (character == null) return;
            StartCoroutine(DashCoroutine(direction));
        }

        private IEnumerator DashCoroutine(Vector3 direction)
        {
            Vector3 startPos = character.transform.position;
            Vector3 endPos = startPos + direction.normalized * dashDistance;
            float elapsed = 0f;

            while (elapsed < dashDuration)
            {
                elapsed += Time.deltaTime;
                float t = elapsed / dashDuration;

                // 使用缓动曲线
                t = Mathf.SmoothStep(0, 1, t);

                Vector3 newPos = Vector3.Lerp(startPos, endPos, t);
                character.transform.position = newPos;

                yield return null;
            }

            character.transform.position = endPos;
        }
    }
}
```

---

## 投掷物系统

### 投掷物基类

```csharp
public class GrenadeProjectile : MonoBehaviour
{
    public float delayTime = 3f;
    public float damageRange = 5f;
    public float throwForce = 15f;
    public float throwAngle = 30f;
    public bool hasCollideSound = true;
    public string collideSound = "GrenadeCollide";
    public bool isDangerForAi = true;

    protected DamageInfo damageInfo;
    protected CharacterMainControl thrower;
    protected bool canHurtSelf;
    protected Rigidbody rb;

    public void SetDamageInfo(DamageInfo info)
    {
        this.damageInfo = info;
    }

    public void Launch(Vector3 position, Vector3 velocity,
        CharacterMainControl thrower, bool canHurtSelf)
    {
        this.thrower = thrower;
        this.canHurtSelf = canHurtSelf;

        transform.position = position;

        // 添加刚体
        rb = gameObject.AddComponent<Rigidbody>();
        rb.useGravity = true;
        rb.velocity = velocity;

        // 延时爆炸
        StartCoroutine(DelayedExplosion());
    }

    private IEnumerator DelayedExplosion()
    {
        yield return new WaitForSeconds(delayTime);
        Explode();
    }

    protected virtual void Explode()
    {
        // 子类实现爆炸逻辑
        Destroy(gameObject);
    }
}
```

### 爆炸伤害逻辑

```csharp
protected void DealExplosionDamage()
{
    Vector3 center = transform.position;

    // 检测范围内所有碰撞体
    Collider[] hits = Physics.OverlapSphere(center, damageRange);

    foreach (Collider hit in hits)
    {
        // 跳过自己（如果设置了不伤害自己）
        if (!canHurtSelf && hit.transform.root == thrower?.transform)
            continue;

        // 获取伤害接收器
        DamageReceiver receiver = hit.GetComponent<DamageReceiver>();
        if (receiver == null) continue;

        // 计算距离衰减
        float distance = Vector3.Distance(center, hit.transform.position);
        float falloff = 1f - (distance / damageRange);
        falloff = Mathf.Clamp01(falloff);

        // 创建伤害信息
        DamageInfo explosionDamage = new DamageInfo(thrower);
        explosionDamage.damageValue = damageInfo.damageValue * falloff;
        explosionDamage.damageType = DamageTypes.explosion;
        explosionDamage.hitPoint = hit.ClosestPoint(center);

        // 造成伤害
        receiver.TakeDamage(explosionDamage);
    }
}
```

### 爆炸特效

```csharp
protected void CreateExplosionEffect()
{
    // 创建爆炸特效对象
    GameObject effectObj = new GameObject("ExplosionEffect");
    effectObj.transform.position = transform.position;

    // 添加光源
    Light light = effectObj.AddComponent<Light>();
    light.type = LightType.Point;
    light.color = Color.yellow;
    light.intensity = 5f;
    light.range = damageRange;

    // 自动销毁
    Destroy(effectObj, 0.5f);
}
```

---

## 虫洞手雷投掷物示例

```csharp
using UnityEngine;
using System.Collections;
using Duckov;
using ItemStatsSystem;

namespace MyMod
{
    public class WormholeGrenadeProjectile : GrenadeProjectile
    {
        private bool hasExploded = false;

        protected override void Explode()
        {
            if (hasExploded) return;
            hasExploded = true;

            Debug.Log("[虫洞手雷] 爆炸!");

            // 1. 传送范围内的敌人
            TeleportEnemies();

            // 2. 创建特效
            CreateWormholeEffect();

            // 3. 销毁投掷物
            Destroy(gameObject);
        }

        private void TeleportEnemies()
        {
            Vector3 center = transform.position;
            Collider[] hits = Physics.OverlapSphere(center, damageRange);

            foreach (Collider hit in hits)
            {
                CharacterMainControl character = hit.GetComponentInParent<CharacterMainControl>();
                if (character == null) continue;

                // 跳过投掷者（如果设置了不伤害自己）
                if (!canHurtSelf && character == thrower) continue;

                // 随机传送位置
                Vector3 randomOffset = Random.insideUnitSphere * damageRange;
                randomOffset.y = 0;
                Vector3 teleportPos = center + randomOffset;

                // 传送
                character.transform.position = teleportPos;
                Debug.Log($"[虫洞手雷] 传送 {character.name} 到 {teleportPos}");
            }
        }

        private void CreateWormholeEffect()
        {
            // 创建虫洞视觉效果
            GameObject effectObj = new GameObject("WormholeEffect");
            effectObj.transform.position = transform.position;

            // 添加紫色光源
            Light light = effectObj.AddComponent<Light>();
            light.type = LightType.Point;
            light.color = new Color(0.5f, 0f, 1f);
            light.intensity = 8f;
            light.range = damageRange * 1.5f;

            Destroy(effectObj, 1f);
        }

        private void OnCollisionEnter(Collision collision)
        {
            if (hasCollideSound)
            {
                // 播放碰撞音效
                Debug.Log($"[虫洞手雷] 碰撞音效: {collideSound}");
            }
        }
    }
}
```

---

## 战斗事件监听

```csharp
void Start()
{
    LevelManager.OnLevelInitialized += () => {
        var player = LevelManager.Instance.MainCharacter;

        // 监听受伤事件
        player.Health.OnHurtEvent.AddListener(OnPlayerHurt);

        // 监听死亡事件
        player.Health.OnDeadEvent.AddListener(OnPlayerDead);

        // 监听射击事件
        player.OnShootEvent += OnPlayerShoot;

        // 监听近战攻击事件
        player.OnAttackEvent += OnPlayerAttack;
    };
}

void OnPlayerHurt(DamageInfo info)
{
    Debug.Log($"受到 {info.damageValue} 点 {info.elementType} 伤害");
    if (info.isCritical) Debug.Log("暴击！");
}

void OnPlayerDead(DamageInfo info)
{
    Debug.Log("玩家死亡");
}

void OnPlayerShoot(DuckovItemAgent agent)
{
    Debug.Log($"使用 {agent.Item.DisplayName} 射击");
}

void OnPlayerAttack(DuckovItemAgent agent)
{
    Debug.Log($"使用 {agent.Item.DisplayName} 近战攻击");
}
```

---

## 常用 Stats 属性

| 属性名 | 说明 | 典型值 |
|--------|------|--------|
| Damage | 伤害 | 10-100 |
| CritRate | 暴击率 | 0.05-0.3 |
| CritDamageFactor | 暴击伤害倍率 | 1.5-2.5 |
| ArmorPiercing | 护甲穿透 | 0-50 |
| AttackSpeed | 攻击速度 | 0.5-2.0 |
| AttackRange | 攻击范围 | 1-5 |
| StaminaCost | 体力消耗 | 5-20 |
| BleedChance | 流血几率 | 0-0.5 |

---

## 格挡系统

```csharp
public class BlockSystem : MonoBehaviour
{
    public float blockAngle = 90f;         // 格挡角度
    public float damageReduction = 0.5f;   // 伤害减免
    public float staminaCostPerBlock = 10f; // 每次格挡消耗体力

    private bool isBlocking = false;
    private CharacterMainControl character;

    public void StartBlock()
    {
        isBlocking = true;
    }

    public void EndBlock()
    {
        isBlocking = false;
    }

    /// <summary>
    /// 检查是否能格挡此伤害
    /// </summary>
    public bool TryBlock(DamageInfo damageInfo, out float reducedDamage)
    {
        reducedDamage = damageInfo.damageValue;

        if (!isBlocking) return false;
        if (character.CurrentStamina < staminaCostPerBlock) return false;

        // 检查角度
        Vector3 toAttacker = (damageInfo.fromCharacter.transform.position -
            character.transform.position).normalized;
        float angle = Vector3.Angle(character.transform.forward, toAttacker);

        if (angle > blockAngle / 2f) return false;

        // 成功格挡
        reducedDamage = damageInfo.damageValue * (1f - damageReduction);
        character.UseStamina(staminaCostPerBlock);

        return true;
    }
}
```

---

## 常见问题

### 伤害不生效

1. 检查目标是否有 `DamageReceiver` 组件
2. 检查 `DamageInfo.damageValue` 是否 > 0
3. 检查目标是否无敌状态

### 近战攻击检测不到敌人

1. 检查 `AttackRange` 是否合适
2. 检查 `Physics.OverlapSphere` 的层级设置
3. 确认敌人有正确的碰撞体

### 投掷物不爆炸

1. 检查 `delayTime` 设置
2. 确认 `Explode()` 方法被调用
3. 检查协程是否正常运行
